import { useState } from "react";
import axios from "axios";
import Swal from "sweetalert2";
import { jsPDF } from "jspdf";
import { Document, Packer, Paragraph, TextRun } from "docx";
import { saveAs } from "file-saver";

const API = `${process.env.REACT_APP_BACKEND_URL}/api`;

export const useTranscript = ({ currentMeeting, language }) => {
  const [transcript, setTranscript] = useState([]);
  const [summary, setSummary] = useState(null);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const [isSummarizing, setIsSummarizing] = useState(false);

  const showAlert = (title, icon) => {
    Swal.fire({
      title,
      icon,
      timer: 2000,
      showConfirmButton: false,
      toast: true,
      position: "top-end",
    });
  };

  const sendSummaryEmail = async (summaryData) => {
    try {
      // ✅ Helper to build HTML sections
      const formatSection = (title, items) => {
        if (!items || !items.length) return "";
        return `
        <div class="section">
          <h2>${title}</h2>
          <ul>
            ${items.map((i) => `<li>${i}</li>`).join("")}
          </ul>
        </div>
      `;
      };

      // ✅ Build HTML template
      const formattedSummary = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <title>Meeting Summary</title>
        <style>
          body { font-family: Arial, sans-serif; background: #f7f9fc; margin: 0; padding: 0; color: #333; }
          .container { max-width: 700px; margin: 30px auto; background: #fff; border-radius: 10px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
          .header { background: #3b82f6; color: #fff; padding: 20px; text-align: center; }
          .header h1 { margin: 0; font-size: 22px; }
          .content { padding: 20px 30px; }
          .section { margin-bottom: 20px; }
          .section h2 { font-size: 18px; color: #3b82f6; border-bottom: 1px solid #eee; padding-bottom: 5px; }
          .section ul { margin: 10px 0; padding-left: 20px; }
          .section ul li { margin-bottom: 6px; line-height: 1.4; }
          .footer { background: #f1f5f9; padding: 15px 20px; font-size: 12px; color: #666; text-align: center; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>📋 Meeting Summary</h1>
            <p>${currentMeeting?.title || "Untitled"}</p>
          </div>
          <div class="content">
            ${formatSection("Key Points", summaryData.key_points)}
            ${formatSection("Action Items", summaryData.action_items)}
            ${formatSection("Deadlines", summaryData.deadlines)}
            ${formatSection("Decisions Made", summaryData.decisions_made)}
            ${formatSection("Unresolved Issues", summaryData.unresolved_issues)}
            ${formatSection("Follow-ups", summaryData.followup_reminders)}
            ${formatSection(
              "AI Recommendations",
              summaryData.ai_recommendations
            )}
            ${formatSection(
              "Attendee Recommendations",
              summaryData.attendee_recommendations
            )}
            ${formatSection("References", summaryData.references)}
          </div>
          <div class="footer">
            <p>This summary was generated by <strong>AI Meeting Assistant</strong>.</p>
          </div>
        </div>
      </body>
      </html>
    `;

      // ✅ Send HTML instead of plain text
      await axios.post(
        "https://n8n-latest-h3pu.onrender.com/webhook/f4920b87-f1c8-4f49-9e60-d54f575d9ef9",
        {
          meeting_id: currentMeeting.id,
          title: currentMeeting.title,
          summary: formattedSummary, // now HTML instead of plain text
          email: localStorage.getItem("email"),
        },
        { headers: getAuthHeaders() }
      );

      showAlert("Summary emailed successfully", "success");
    } catch (error) {
      console.error("Error sending summary email:", error);
      showAlert("Failed to send summary email", "error");
    }
  };

  const getAuthHeaders = () => {
    const token = localStorage.getItem("token");
    return {
      Authorization: `Bearer ${token}`,
    };
  };

  const handleFileUpload = async (file) => {
    if (!file || !currentMeeting) return;

    setIsTranscribing(true);
    showAlert("Transcribing audio file...", "info");

    try {
      const formData = new FormData();
      formData.append("audio_file", file);

      const response = await axios.post(
        `${API}/meetings/${currentMeeting.id}/transcribe-file`,
        formData,
        {
          headers: {
            "Content-Type": "multipart/form-data",
            ...getAuthHeaders(),
          },
          timeout: 120000,
        }
      );

      setTranscript(response.data.transcript || []);
      showAlert("Audio transcribed successfully", "success");
    } catch (error) {
      console.error("Error transcribing file:", error);
      showAlert("Failed to transcribe audio file", "error");
    } finally {
      setIsTranscribing(false);
    }
  };

  const generateSummary = async () => {
    console.log(
      "Generate summary: ++++++++++++++++++",
      transcript,
      currentMeeting
    );
    if (!currentMeeting || transcript.length === 0) {
      showAlert("No transcript available to summarize", "warning");
      return;
    }

    setIsSummarizing(true);
    showAlert("Generating AI summary...", "info");

    try {
      const transcriptText = transcript
        .map((seg) => `${seg.speaker}: ${seg.text}`)
        .join("\n");

      const response = await axios.post(
        `${API}/meetings/${currentMeeting.id}/summarize`,
        {
          meeting_id: currentMeeting.id,
          transcript_text: transcriptText,
          language: language,
        },
        { headers: getAuthHeaders() }
      );

      const generatedSummary = response.data.summary;
      setSummary(generatedSummary);
      showAlert("Summary generated successfully", "success");

      // ✅ Auto-send email after summary is created
      await sendSummaryEmail(generatedSummary);
    } catch (error) {
      console.error("Error generating summary:", error);
      showAlert("Failed to generate summary", "error");
    } finally {
      setIsSummarizing(false);
    }
  };

  const copyToClipboard = async () => {
    const content = `Meeting: ${
      currentMeeting?.title
    }\n\nTranscript:\n${transcript
      .map((seg) => `${seg.speaker}: ${seg.text}`)
      .join("\n")}\n\nSummary:\n${
      summary ? JSON.stringify(summary, null, 2) : "No summary available"
    }`;

    try {
      await navigator.clipboard.writeText(content);
      showAlert("Copied to clipboard", "success");
    } catch (error) {
      showAlert("Failed to copy to clipboard", "error");
    }
  };

  const exportToPDF = () => {
    if (!transcript.length) {
      showAlert("No transcript available", "warning");
      return;
    }

    const doc = new jsPDF();
    let y = 20;

    // Meeting Title
    doc.setFont("helvetica", "bold");
    doc.setFontSize(16);
    doc.text(`Meeting: ${currentMeeting?.title || "Untitled"}`, 10, y);
    y += 10;

    // Transcript Heading
    doc.setFontSize(14);
    doc.text("Transcript", 10, y);
    y += 10;

    doc.setFont("helvetica", "normal");
    doc.setFontSize(12);
    transcript.forEach((seg) => {
      const text = `${seg.speaker}: ${seg.text}`;
      const lines = doc.splitTextToSize(text, 180); // wrap text
      doc.text(lines, 10, y);
      y += lines.length * 7;

      if (y > 280) {
        doc.addPage();
        y = 20;
      }
    });

    if (summary) {
      // Add Summary Section
      doc.addPage();
      y = 20;

      doc.setFont("helvetica", "bold");
      doc.setFontSize(16);
      doc.text("Summary", 10, y);
      y += 12;

      const addSection = (title, items) => {
        if (!items || !items.length) return;
        doc.setFontSize(14);
        doc.text(title, 10, y);
        y += 8;

        doc.setFont("helvetica", "normal");
        doc.setFontSize(12);
        items.forEach((item) => {
          const lines = doc.splitTextToSize(`• ${item}`, 180);
          doc.text(lines, 15, y);
          y += lines.length * 7;

          if (y > 280) {
            doc.addPage();
            y = 20;
          }
        });

        y += 5; // space after section
      };

      addSection("Key Points", summary.key_points);
      addSection("Action Items", summary.action_items);
      addSection("Deadlines", summary.deadlines);
      addSection("Decisions Made", summary.decisions_made);
      addSection("Unresolved Issues", summary.unresolved_issues);
      addSection("Follow-ups", summary.followup_reminders);
      addSection("AI Recommendations", summary.ai_recommendations);
      addSection("Attendee Recommendations", summary.attendee_recommendations);
      addSection("References", summary.references);
    }

    doc.save(`${currentMeeting?.title || "meeting"}_transcript.pdf`);
    showAlert("PDF downloaded", "success");
  };

  const exportToWord = async () => {
    if (!transcript.length) {
      showAlert("No transcript available", "warning");
      return;
    }

    const transcriptParagraphs = transcript.map(
      (seg) =>
        new Paragraph({
          children: [
            new TextRun({ text: `${seg.speaker}: `, bold: true }),
            new TextRun(seg.text),
          ],
        })
    );

    // 📝 Format summary sections nicely
    const summarySections = summary
      ? [
          new Paragraph({
            children: [new TextRun({ text: "Summary", bold: true, size: 28 })],
            spacing: { before: 400, after: 200 },
          }),
          ...(summary.key_points || []).map(
            (point) =>
              new Paragraph({
                children: [new TextRun({ text: `• ${point}` })],
                bullet: { level: 0 },
              })
          ),
          new Paragraph({
            children: [
              new TextRun({ text: "Action Items", bold: true, size: 24 }),
            ],
            spacing: { before: 300, after: 150 },
          }),
          ...(summary.action_items || []).map(
            (item) =>
              new Paragraph({
                children: [new TextRun({ text: `• ${item}` })],
                bullet: { level: 0 },
              })
          ),
          new Paragraph({
            children: [
              new TextRun({ text: "Deadlines", bold: true, size: 24 }),
            ],
            spacing: { before: 300, after: 150 },
          }),
          ...(summary.deadlines || []).map(
            (d) =>
              new Paragraph({
                children: [new TextRun({ text: `• ${d}` })],
                bullet: { level: 0 },
              })
          ),
          new Paragraph({
            children: [
              new TextRun({ text: "Decisions Made", bold: true, size: 24 }),
            ],
            spacing: { before: 300, after: 150 },
          }),
          ...(summary.decisions_made || []).map(
            (d) =>
              new Paragraph({
                children: [new TextRun({ text: `• ${d}` })],
                bullet: { level: 0 },
              })
          ),
          new Paragraph({
            children: [
              new TextRun({ text: "Unresolved Issues", bold: true, size: 24 }),
            ],
            spacing: { before: 300, after: 150 },
          }),
          ...(summary.unresolved_issues || []).map(
            (u) =>
              new Paragraph({
                children: [new TextRun({ text: `• ${u}` })],
                bullet: { level: 0 },
              })
          ),
          new Paragraph({
            children: [
              new TextRun({ text: "Follow-ups", bold: true, size: 24 }),
            ],
            spacing: { before: 300, after: 150 },
          }),
          ...(summary.followup_reminders || []).map(
            (f) =>
              new Paragraph({
                children: [new TextRun({ text: `• ${f}` })],
                bullet: { level: 0 },
              })
          ),
        ]
      : [new Paragraph("No summary available")];

    const doc = new Document({
      sections: [
        {
          children: [
            new Paragraph({
              children: [
                new TextRun({
                  text: `Meeting: ${currentMeeting?.title || "Untitled"}`,
                  bold: true,
                  size: 32,
                }),
              ],
              spacing: { after: 400 },
            }),
            new Paragraph({
              children: [
                new TextRun({ text: "Transcript", bold: true, size: 28 }),
              ],
              spacing: { after: 200 },
            }),
            ...transcriptParagraphs,
            ...summarySections,
          ],
        },
      ],
    });

    const blob = await Packer.toBlob(doc);
    saveAs(blob, `${currentMeeting?.title || "meeting"}_transcript.docx`);
    showAlert("Word file downloaded", "success");
  };

  return {
    transcript,
    setTranscript,
    summary,
    setSummary,
    isTranscribing,
    isSummarizing,
    handleFileUpload,
    generateSummary,
    exportToPDF,
    exportToWord,
    copyToClipboard,
  };
};
